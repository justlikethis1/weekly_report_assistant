#!/usr/bin/env python3
"""
Word文档生成器
用于生成Word格式的报告文档
"""

from typing import Dict, Any, List
import os
import logging
from pathlib import Path
from datetime import datetime

# 导入Word文档生成库
try:
    from docx import Document as DocxDocument
    from docx.shared import Inches, Pt, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_BREAK
except ImportError:
    logging.warning("python-docx not installed, Word document generation may be limited")
    DocxDocument = None
    
logger = logging.getLogger(__name__)

class WordGenerator:
    """Word文档生成器类"""
    
    def __init__(self):
        """初始化Word文档生成器"""
        if DocxDocument is None:
            raise ImportError("python-docx not installed, cannot generate Word documents")
        
        logger.info("WordGenerator initialized")
    
    def create_report(self, title: str, content: str, author: str = "系统", 
                     date: str = None, save_path: str = None) -> str:
        """
        创建Word格式的报告文档
        
        Args:
            title: 报告标题
            content: 报告内容
            author: 作者
            date: 日期
            save_path: 保存路径
            
        Returns:
            str: 保存的文件路径
        """
        try:
            # 创建文档
            doc = DocxDocument()
            
            # 设置日期
            if date is None:
                date = datetime.now().strftime("%Y年%m月%d日")
            
            # 1. 添加标题
            self._add_title(doc, title)
            
            # 2. 添加副标题/元信息
            self._add_subtitle(doc, author, date)
            
            # 3. 添加报告内容
            self._add_content(doc, content)
            
            # 4. 添加页脚
            self._add_footer(doc)
            
            # 5. 保存文档
            if save_path is None:
                # 生成默认保存路径
                output_dir = Path("output")
                output_dir.mkdir(exist_ok=True)
                save_filename = f"{title}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.docx"
                save_path = str(output_dir / save_filename)
            
            doc.save(save_path)
            logger.info(f"Word report saved to: {save_path}")
            
            return save_path
            
        except Exception as e:
            logger.error(f"Failed to create Word report: {str(e)}")
            raise
    
    def _add_title(self, doc: DocxDocument, title: str):
        """添加标题"""
        # 添加标题
        title_paragraph = doc.add_heading(level=0)
        title_run = title_paragraph.add_run(title)
        title_run.font.size = Pt(24)
        title_run.font.color.rgb = RGBColor(0, 0, 0)  # 黑色
        title_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # 添加空行
        doc.add_paragraph()
    
    def _add_subtitle(self, doc: DocxDocument, author: str, date: str):
        """添加副标题/元信息"""
        # 添加作者信息
        author_paragraph = doc.add_paragraph(f"作者：{author}")
        author_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # 添加日期信息
        date_paragraph = doc.add_paragraph(f"日期：{date}")
        date_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # 添加空行
        doc.add_paragraph()
    
    def _add_content(self, doc: DocxDocument, content: str):
        """添加报告内容"""
        # 按段落拆分内容
        paragraphs = content.split("\n\n")  # 假设内容是用两个换行分隔段落的
        
        for i, paragraph in enumerate(paragraphs):
            if not paragraph.strip():
                continue
            
            # 检查是否是章节标题（以数字加顿号开头，如"1. "或"一、"）
            if self._is_chapter_title(paragraph):
                # 添加章节标题
                heading_level = self._get_heading_level(paragraph)
                heading_paragraph = doc.add_heading(paragraph.strip(), level=heading_level)
                heading_run = heading_paragraph.runs[0]
                heading_run.font.size = Pt(16 if heading_level == 1 else 14)
                heading_run.font.bold = True
            else:
                # 添加普通段落
                p = doc.add_paragraph(paragraph.strip())
                p.paragraph_format.line_spacing = 1.5  # 设置行间距为1.5倍
    
    def _add_footer(self, doc: DocxDocument):
        """添加页脚"""
        # 遍历所有节
        for section in doc.sections:
            footer = section.footer
            footer_paragraph = footer.paragraphs[0] if footer.paragraphs else footer.add_paragraph()
            
            # 添加页脚内容
            footer_run = footer_paragraph.add_run("Generated by Weekly Report Assistant")
            footer_run.font.size = Pt(10)
            footer_run.font.color.rgb = RGBColor(128, 128, 128)  # 灰色
            footer_paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    def _is_chapter_title(self, text: str) -> bool:
        """判断是否是章节标题"""
        # 检查是否以数字加顿号开头（如"1. "）
        if text.startswith("\n"):
            text = text[1:]
        if text.endswith("\n"):
            text = text[:-1]
            
        import re
        # 匹配章节标题格式：1. 标题、1.1 子标题、一、标题、（一）子标题等
        patterns = [
            r'^\d+\.\s.*',  # 1. 标题
            r'^\d+\.\d+\s.*',  # 1.1 子标题
            r'^[一二三四五六七八九十]+、.*',  # 一、标题
            r'^\([一二三四五六七八九十]+\)\s.*',  # （一）子标题
            r'^[123]\)\s.*',  # 1) 列表项
            r'^[①②③④⑤⑥⑦⑧⑨⑩]\s.*'  # ① 列表项
        ]
        
        for pattern in patterns:
            if re.match(pattern, text):
                return True
        
        return False
    
    def _get_heading_level(self, text: str) -> int:
        """获取标题级别"""
        import re
        
        if re.match(r'^\d+\.\s.*', text):
            return 1  # 一级标题：1. 标题
        elif re.match(r'^\d+\.\d+\s.*', text):
            return 2  # 二级标题：1.1 标题
        elif re.match(r'^[一二三四五六七八九十]+、.*', text):
            return 1  # 一级标题：一、标题
        elif re.match(r'^\([一二三四五六七八九十]+\)\s.*', text):
            return 2  # 二级标题：（一）标题
        elif re.match(r'^[123]\)\s.*', text):
            return 3  # 三级标题：1) 列表项
        elif re.match(r'^[①②③④⑤⑥⑦⑧⑨⑩]\s.*', text):
            return 3  # 三级标题：① 列表项
        else:
            return 2  # 默认二级标题
    
    def batch_generate_reports(self, report_data_list: List[Dict[str, Any]]) -> List[str]:
        """
        批量生成报告
        
        Args:
            report_data_list: 报告数据列表，每个元素是包含title、content、author等字段的字典
            
        Returns:
            List[str]: 生成的报告文件路径列表
        """
        generated_files = []
        
        for report_data in report_data_list:
            try:
                file_path = self.create_report(**report_data)
                generated_files.append(file_path)
            except Exception as e:
                logger.error(f"Failed to generate report {report_data.get('title')}: {str(e)}")
                continue
        
        return generated_files
        
    def generate_report(self, content: str, save_path: str, is_chinese: bool, report_type: str = "weekly") -> bool:
        """
        生成报告的包装方法，用于兼容UI层的调用
        
        Args:
            content: 报告内容
            save_path: 保存路径
            is_chinese: 是否是中文报告
            report_type: 报告类型
            
        Returns:
            bool: 是否成功生成报告
        """
        try:
            # 根据报告类型生成标题
            if report_type == "weekly":
                title = "周报" if is_chinese else "Weekly Report"
            elif report_type == "daily":
                title = "日报" if is_chinese else "Daily Report"
            elif report_type == "monthly":
                title = "月报" if is_chinese else "Monthly Report"
            else:
                title = f"{report_type}报告" if is_chinese else f"{report_type} Report"
            
            # 调用实际的create_report方法
            self.create_report(title, content, save_path=save_path)
            return True
        except Exception as e:
            logger.error(f"Failed to generate report: {str(e)}")
            return False

# 创建单例实例
try:
    word_generator = WordGenerator()
except ImportError:
    word_generator = None
    logging.warning("WordGenerator not available due to missing dependencies")